# ç¼–ç è§„èŒƒæ–‡æ¡£ï¼ˆCDSï¼‰

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
> **åˆ›å»ºæ—¥æœŸ**: 2026-01-31
> **æ–‡æ¡£ç±»å‹**: å¼€å‘è§„èŒƒ
> **çŠ¶æ€**: âœ… å·²æ‰¹å‡†

---

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

### æ–‡æ¡£ç›®çš„

æœ¬æ–‡æ¡£å®šä¹‰ LiteKV é¡¹ç›®çš„ç¼–ç è§„èŒƒï¼ŒåŒ…æ‹¬ä»£ç é£æ ¼ã€å‘½åçº¦å®šã€æ³¨é‡Šè§„èŒƒå’Œæœ€ä½³å®è·µã€‚æ‰€æœ‰ä»£ç å¿…é¡»éµå¾ªè¿™äº›è§„èŒƒï¼Œä»¥ç¡®ä¿ä»£ç çš„ä¸€è‡´æ€§ã€å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

### é€‚ç”¨èŒƒå›´

- **é¡¹ç›®**: LiteKV åˆ†å¸ƒå¼ KV å­˜å‚¨ç³»ç»Ÿ
- **è¯­è¨€**: Rust 1.81.0+ (MSRV)
- **é€‚ç”¨äººå‘˜**: ğŸ¤– å…¨ä½“ AI å¼€å‘å·¥ç¨‹å¸ˆã€ğŸ‘¤ æ¶æ„å¸ˆï¼ˆä»£ç å®¡æŸ¥å’Œæ‰¹å‡†ï¼‰

### å‚è€ƒæ–‡æ¡£

- [Rust API Guidelines](https://rust-lang.github.io/api-guidelines/)
- [Effective Rust](https://doc.rust-lang.org/book/)
- [Rust Style Guide](https://rust-lang.github.io/rustfmt/)
- `CLAUDE.md` - å¼€å‘æµç¨‹è§„èŒƒ

---

## æ ¸å¿ƒåŸåˆ™

| åŸåˆ™ | è¯´æ˜ |
|------|------|
| **å¯è¯»æ€§** | ä»£ç æ˜¯å†™ç»™äººçœ‹çš„ï¼Œæœºå™¨åªæ˜¯é¡ºä¾¿æ‰§è¡Œ |
| **ç®€æ´æ€§** | é¿å…è¿‡åº¦è®¾è®¡ï¼Œä¿æŒä»£ç ç®€å•æ˜äº† |
| **ä¸€è‡´æ€§** | éµå¾ªå›¢é˜Ÿè§„èŒƒï¼Œç»Ÿä¸€ä»£ç é£æ ¼ |
| **æµ‹è¯•é©±åŠ¨** | ä¿è¯ä»£ç è´¨é‡ï¼Œæµ‹è¯•å…ˆè¡Œ |
| **æ€§èƒ½ä¼˜å…ˆ** | æ€§èƒ½æ˜¯æ ¸å¿ƒç«äº‰åŠ› |

**å·¥å…·æ¨è**ï¼š

| å·¥å…· | ç”¨é€” | å¿…éœ€æ€§ |
|------|------|--------|
| `cargo fmt` | ä»£ç æ ¼å¼åŒ– | âœ… å¿…éœ€ |
| `cargo clippy` | Lint æ£€æŸ¥ | âœ… å¿…éœ€ |
| `cargo doc` | æ–‡æ¡£ç”Ÿæˆ | âœ… å¿…éœ€ |
| `cargo test` | å•å…ƒæµ‹è¯• | âœ… å¿…éœ€ |
| `cargo miri` | æœªå®šä¹‰è¡Œä¸ºæ£€æµ‹ | âš ï¸ æ¨è |
| `cargo audit` | å®‰å…¨æ¼æ´æ£€æŸ¥ | âš ï¸ æ¨è |

---

## ç›®å½•

- [1. Rust ä»£ç è§„èŒƒ](#1-rust-ä»£ç è§„èŒƒ)
  - [1.1 åŸºç¡€è§„èŒƒ](#11-åŸºç¡€è§„èŒƒ)
  - [1.2 å‘½åçº¦å®š](#12-å‘½åçº¦å®š)
  - [1.3 å‡½æ•°è§„èŒƒ](#13-å‡½æ•°è§„èŒƒ)
  - [1.4 ç»“æ„ä½“è§„èŒƒ](#14-ç»“æ„ä½“è§„èŒƒ)
  - [1.5 å¹¶å‘è§„èŒƒ](#15-å¹¶å‘è§„èŒƒ)
  - [1.6 é”™è¯¯å¤„ç†è§„èŒƒ](#16-é”™è¯¯å¤„ç†è§„èŒƒ)
- [2. æ³¨é‡Šè§„èŒƒ](#2-æ³¨é‡Šè§„èŒƒ)
- [3. æµ‹è¯•è§„èŒƒ](#3-æµ‹è¯•è§„èŒƒ)
- [4. æ€§èƒ½è§„èŒƒ](#4-æ€§èƒ½è§„èŒƒ)
- [5. å®‰å…¨è§„èŒƒ](#5-å®‰å…¨è§„èŒƒ)
- [6. Git æäº¤è§„èŒƒ](#6-git-æäº¤è§„èŒƒ)

---

## 1. Rust ä»£ç è§„èŒƒ

### 1.1 åŸºç¡€è§„èŒƒ

#### éµå¾ªå®˜æ–¹è§„èŒƒ

LiteKV é¡¹ç›®ä¸¥æ ¼éµå¾ª Rust è¯­è¨€å®˜æ–¹ç¼–ç è§„èŒƒï¼š

- [Rust API Guidelines](https://rust-lang.github.io/api-guidelines/)
- [The Rust Book](https://doc.rust-lang.org/book/)

#### ä»£ç æ ¼å¼åŒ–

**è‡ªåŠ¨åŒ–æ ¼å¼åŒ–**ï¼š
```bash
# ä½¿ç”¨ rustfmt è‡ªåŠ¨æ ¼å¼åŒ–
cargo fmt
```

**CI/CD æ£€æŸ¥**ï¼š
- æ‰€æœ‰æäº¤å¿…é¡»é€šè¿‡ `cargo fmt` æ£€æŸ¥
- æœªæ ¼å¼åŒ–çš„ä»£ç å°†è¢«æ‹’ç»åˆå¹¶

#### ä»£ç æ£€æŸ¥

**é™æ€åˆ†æ**ï¼š
```bash
# ä½¿ç”¨ clippy è¿›è¡Œ lint æ£€æŸ¥
cargo clippy -- -D warnings
```

**æ£€æŸ¥è§„åˆ™**ï¼š
- æ‰€æœ‰ warnings å¿…é¡»ä¿®å¤æˆ–åˆç†è¯´æ˜
- ç¦æ­¢ä½¿ç”¨ `#[allow(...)]` ç»•è¿‡è­¦å‘Šï¼ˆé™¤éæœ‰å……åˆ†ç†ç”±ï¼‰

---

### 1.2 å‘½åçº¦å®š

#### åŸºæœ¬è§„åˆ™

| ç±»å‹ | å‘½åé£æ ¼ | ç¤ºä¾‹ |
|------|----------|------|
| **æ¨¡å—** | snake_case | `mod btree_map;` |
| **ç±»å‹** | PascalCase | `struct BTreeMap;` |
| **Trait** | PascalCase | `trait Storage;` |
| **å‡½æ•°** | snake_case | `fn get_value();` |
| **å˜é‡** | snake_case | `let max_size = 100;` |
| **å¸¸é‡** | SCREAMING_SNAKE_CASE | `const MAX_SIZE: usize = 100;` |
| **é™æ€å˜é‡** | SCREAMING_SNAKE_CASE | `static GLOBAL_CONFIG: Mutex<Config> = ...;` |
| **ç”Ÿå‘½å‘¨æœŸå‚æ•°** | çŸ­å°å†™ | `'a`, `'ctx` |
| **æ³›å‹å‚æ•°** | ç®€çŸ­å¤§å†™ | `T`, `E`, `K`, `V` |

#### å‘½åæœ€ä½³å®è·µ

```rust
// âœ… å¥½ï¼šæ¸…æ™°ã€æè¿°æ€§å¼º
struct BTreeMap<K, V> { ... }
fn get_user_by_id(id: UserId) -> Option<User> { ... }
const MAX_CONNECTION_COUNT: usize = 100;

// âŒ å·®ï¼šç¼©å†™ã€æ— æ„ä¹‰
struct BTM<K, V> { ... }
fn get(u: i32) -> Option<User> { ... }
const MAX: usize = 100;
```

---

### 1.3 å‡½æ•°è§„èŒƒ

#### å‡½æ•°é•¿åº¦

- **æ¨è**ï¼šå‡½æ•°ä¿æŒåœ¨ 50 è¡Œä»¥å†…
- **ä¸Šé™**ï¼šå‡½æ•°ä¸è¶…è¿‡ 100 è¡Œ
- **åŸåˆ™**ï¼šå•ä¸€èŒè´£ï¼Œåªåšä¸€ä»¶äº‹

```rust
// âœ… å¥½ï¼šå‡½æ•°èŒè´£å•ä¸€
fn parse_request(buf: &[u8]) -> Result<Request> {
    let header = parse_header(buf)?;
    let body = parse_body(buf)?;
    Ok(Request { header, body })
}

// âŒ å·®ï¼šå‡½æ•°è¿‡é•¿ï¼ŒèŒè´£ä¸æ¸…æ™°
fn parse_request(buf: &[u8]) -> Result<Request> {
    // 100+ è¡Œä»£ç ...
}
```

#### å‚æ•°æ•°é‡

- **æ¨è**ï¼šå‚æ•°ä¸è¶…è¿‡ 4 ä¸ª
- **è¶…è¿‡æ—¶**ï¼šä½¿ç”¨ç»“æ„ä½“å°è£…

```rust
// âœ… å¥½ï¼šå‚æ•°å°‘äº 4 ä¸ª
fn create_user(name: String, email: String) -> Result<User> { ... }

// âœ… å¥½ï¼šä½¿ç”¨ç»“æ„ä½“å°è£…
struct UserConfig {
    name: String,
    email: String,
    age: u8,
    address: String,
}
fn create_user(config: UserConfig) -> Result<User> { ... }

// âŒ å·®ï¼šå‚æ•°è¿‡å¤š
fn create_user(name: String, email: String, age: u8, address: String) -> Result<User> { ... }
```

#### è¿”å›å€¼

- **ä½¿ç”¨ `Result`**ï¼šå¯èƒ½å¤±è´¥çš„æ“ä½œè¿”å› `Result<T, E>`
- **ä½¿ç”¨ `Option`**ï¼šå¯èƒ½ä¸å­˜åœ¨çš„å€¼è¿”å› `Option<T>`
- **é¿å…è£¸æŒ‡é’ˆ**ï¼šä½¿ç”¨å¼•ç”¨æˆ–æ™ºèƒ½æŒ‡é’ˆ

```rust
// âœ… å¥½ï¼šä½¿ç”¨ Result å’Œ Option
fn get_user(id: UserId) -> Result<User, Error> { ... }
fn find_user(id: UserId) -> Option<User> { ... }

// âŒ å·®ï¼šä½¿ç”¨è£¸æŒ‡é’ˆæˆ– panic
fn get_user(id: UserId) -> *const User { ... }
fn get_user(id: UserId) -> User { panic!("Not found"); }
```

---

### 1.4 ç»“æ„ä½“è§„èŒƒ

#### å­—æ®µé¡ºåº

```rust
// âœ… å¥½ï¼šæŒ‰ç±»åˆ«æ’åº
struct User {
    // å…¬å…±å­—æ®µ
    id: UserId,
    name: String,

    // ç§æœ‰å­—æ®µ
    email: String,
    created_at: DateTime<Utc>,
}

struct BTreeNode<K, V> {
    // æ³›å‹å‚æ•°
    keys: Vec<K>,
    values: Vec<V>,

    // å…ƒæ•°æ®
    order: usize,
    height: usize,
}
```

#### å®ç° Trait

```rust
// âœ… å¥½ï¼šæŒ‰é€»è¾‘åˆ†ç»„
impl User {
    // æ„é€ å‡½æ•°
    pub fn new(name: String) -> Self { ... }

    // å…¬å…±æ–¹æ³•
    pub fn id(&self) -> UserId { ... }
    pub fn name(&self) -> &str { ... }

    // ç§æœ‰æ–¹æ³•
    fn validate(&self) -> Result<(), Error> { ... }
}

impl Display for User {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.name)
    }
}
```

---

### 1.5 å¹¶å‘è§„èŒƒ

#### ä½¿ç”¨æ¶ˆæ¯ä¼ é€’

```rust
// âœ… å¥½ï¼šä½¿ç”¨ channel è¿›è¡Œé€šä¿¡
use tokio::sync::mpsc;

#[tokio::main]
async fn main() {
    let (tx, mut rx) = mpsc::channel(100);

    tokio::spawn(async move {
        tx.send("Hello").await.unwrap();
    });

    while let Some(msg) = rx.recv().await {
        println!("Received: {}", msg);
    }
}
```

#### å…±äº«çŠ¶æ€

```rust
// âœ… å¥½ï¼šä½¿ç”¨ Arc + Mutex/RwLock
use std::sync::{Arc, Mutex};

struct SharedState {
    counter: Arc<Mutex<usize>>,
}

impl SharedState {
    fn new() -> Self {
        Self {
            counter: Arc::new(Mutex::new(0)),
        }
    }

    fn increment(&self) {
        let mut counter = self.counter.lock().unwrap();
        *counter += 1;
    }
}
```

#### é¿å…æ­»é”

```rust
// âŒ å·®ï¼šå¯èƒ½å¯¼è‡´æ­»é”
fn deadlock_example() {
    let mutex1 = Mutex::new(1);
    let mutex2 = Mutex::new(2);

    let _lock1 = mutex1.lock().unwrap();
    let _lock2 = mutex2.lock().unwrap();
    // å¦‚æœåœ¨å…¶ä»–åœ°æ–¹ä»¥ç›¸åé¡ºåºè·å–é”ï¼Œä¼šæ­»é”
}

// âœ… å¥½ï¼šä½¿ç”¨å›ºå®šçš„é”é¡ºåº
fn no_deadlock_example() {
    let mutex1 = Mutex::new(1);
    let mutex2 = Mutex::new(2);

    // æ€»æ˜¯æŒ‰ç›¸åŒé¡ºåºè·å–é”
    let _lock1 = mutex1.lock().unwrap();
    let _lock2 = mutex2.lock().unwrap();
}
```

---

### 1.6 é”™è¯¯å¤„ç†è§„èŒƒ

#### ä½¿ç”¨ Result

```rust
// âœ… å¥½ï¼šä½¿ç”¨ Result ä¼ æ’­é”™è¯¯
use anyhow::{Result, Context};

fn read_file(path: &str) -> Result<String> {
    let content = std::fs::read_to_string(path)
        .context(format!("Failed to read file: {}", path))?;
    Ok(content)
}

fn process_data() -> Result<Data> {
    let raw = read_file("data.txt")?;
    let parsed = parse(&raw)?;
    Ok(parsed)
}
```

#### è‡ªå®šä¹‰é”™è¯¯ç±»å‹

```rust
// âœ… å¥½ï¼šå®šä¹‰æ¸…æ™°çš„é”™è¯¯ç±»å‹
use thiserror::Error;

#[derive(Error, Debug)]
pub enum StorageError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Serialization error: {0}")]
    Serialization(String),

    #[error("Key not found: {0}")]
    KeyNotFound(String),
}

// ä½¿ç”¨ thiserror è‡ªåŠ¨å®ç° Displayã€Error ç­‰
```

#### é¿å… panic

```rust
// âŒ å·®ï¼šåœ¨åº“ä»£ç ä¸­ä½¿ç”¨ panic
fn get_value(&self, key: &str) -> &str {
    if let Some(value) = self.map.get(key) {
        value
    } else {
        panic!("Key not found") // ä¸è¦è¿™æ ·åš
    }
}

// âœ… å¥½ï¼šè¿”å› Result æˆ– Option
fn get_value(&self, key: &str) -> Option<&str> {
    self.map.get(key).map(|s| s.as_str())
}
```

---

## 2. æ³¨é‡Šè§„èŒƒ

### æ–‡æ¡£æ³¨é‡Š

```rust
/// B-tree èŠ‚ç‚¹ç»“æ„
///
/// # æ³›å‹
/// * `K` - é”®ç±»å‹ï¼Œå¿…é¡»å®ç° Ord trait
/// * `V` - å€¼ç±»å‹
///
/// # ç¤ºä¾‹
/// ```
/// use litekv::btree::BTreeNode;
///
/// let node = BTreeNode::new(3);
/// ```
pub struct BTreeNode<K, V> {
    keys: Vec<K>,
    values: Vec<V>,
    children: Vec<Box<BTreeNode<K, V>>>,
}

impl<K, V> BTreeNode<K, V>
where
    K: Ord,
{
    /// åˆ›å»ºä¸€ä¸ªæ–°çš„ B-tree èŠ‚ç‚¹
    ///
    /// # å‚æ•°
    /// * `order` - B-tree çš„é˜¶æ•°
    ///
    /// # è¿”å›
    /// è¿”å›ä¸€ä¸ªç©ºçš„ B-tree èŠ‚ç‚¹
    pub fn new(order: usize) -> Self {
        Self {
            keys: Vec::with_capacity(order - 1),
            values: Vec::with_capacity(order - 1),
            children: Vec::with_capacity(order),
        }
    }
}
```

### è¡Œå†…æ³¨é‡Š

```rust
// âœ… å¥½ï¼šè§£é‡Šä¸ºä»€ä¹ˆè¿™æ ·åš
// ä½¿ç”¨ B-tree è€Œä¸æ˜¯çº¢é»‘æ ‘ï¼Œå› ä¸º B-tree å¯¹ç£ç›˜ I/O æ›´å‹å¥½
let index = BTreeMap::new();

// âœ… å¥½ï¼šè§£é‡Šå¤æ‚é€»è¾‘
// è®¡ç®—ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„ä½ç½®ï¼šæ ¹æ® B-tree çš„æ€§è´¨ï¼Œå­èŠ‚ç‚¹æ•°é‡æœ€å¤šä¸º order
let child_count = self.children.len();
let mid = child_count / 2;

// âŒ å·®ï¼šé‡å¤ä»£ç æœ¬èº«
// åˆ›å»ºæ–°çš„å­—ç¬¦ä¸²
let s = String::new();
```

---

## 3. æµ‹è¯•è§„èŒƒ

### å•å…ƒæµ‹è¯•

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_new_node() {
        let node: BTreeNode<String, String> = BTreeNode::new(3);
        assert_eq!(node.keys.len(), 0);
        assert_eq!(node.values.len(), 0);
    }

    #[test]
    fn test_insert() {
        let mut node = BTreeNode::new(3);
        node.insert("key1".to_string(), "value1".to_string());
        assert_eq!(node.keys.len(), 1);
    }
}
```

### é›†æˆæµ‹è¯•

```rust
// tests/integration_test.rs
use litekv::Client;

#[tokio::test]
async fn test_set_and_get() {
    let client = Client::connect("localhost:6379").await.unwrap();

    client.set("key", "value").await.unwrap();
    let result = client.get("key").await.unwrap();

    assert_eq!(result, Some("value".to_string()));
}
```

### æµ‹è¯•è¦†ç›–ç‡

- **æœ€ä½è¦æ±‚**ï¼š80% ä»£ç è¦†ç›–ç‡
- **æ¨èç›®æ ‡**ï¼š90% ä»£ç è¦†ç›–ç‡
- **å…³é”®è·¯å¾„**ï¼š100% è¦†ç›–

```bash
# ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
cargo install cargo-tarpaulin
cargo tarpaulin --out Html
```

---

## 4. æ€§èƒ½è§„èŒƒ

### é¿å…ä¸å¿…è¦çš„åˆ†é…

```rust
// âŒ å·®ï¼šå¤šæ¬¡åˆ†é…
fn concat_strings(strings: &[&str]) -> String {
    let mut result = String::new();
    for s in strings {
        result = result + s; // æ¯æ¬¡éƒ½é‡æ–°åˆ†é…
    }
    result
}

// âœ… å¥½ï¼šä½¿ç”¨ with_capacity é¢„åˆ†é…
fn concat_strings(strings: &[&str]) -> String {
    let total_len = strings.iter().map(|s| s.len()).sum();
    let mut result = String::with_capacity(total_len);
    for s in strings {
        result.push_str(s);
    }
    result
}
```

### ä½¿ç”¨è¿­ä»£å™¨

```rust
// âœ… å¥½ï¼šä½¿ç”¨è¿­ä»£å™¨é“¾å¼è°ƒç”¨
fn process_items(items: &[i32]) -> Vec<i32> {
    items.iter()
        .filter(|&&x| x > 0)
        .map(|&x| x * 2)
        .collect()
}
```

### é¿å…å…‹éš†

```rust
// âŒ å·®ï¼šä¸å¿…è¦çš„å…‹éš†
fn print_name(user: &User) {
    println!("{}", user.name.clone()); // ä¸éœ€è¦å…‹éš†
}

// âœ… å¥½ï¼šä½¿ç”¨å¼•ç”¨
fn print_name(user: &User) {
    println!("{}", user.name);
}
```

---

## 5. å®‰å…¨è§„èŒƒ

### è¾“å…¥éªŒè¯

```rust
use validator::Validate;

#[derive(Debug, Validate)]
struct UserInput {
    #[validate(length(min = 1, max = 100))]
    name: String,

    #[validate(email)]
    email: String,
}

fn create_user(input: UserInput) -> Result<User> {
    input.validate()?;
    // åˆ›å»ºç”¨æˆ·...
}
```

### é¿å…æ•æ„Ÿä¿¡æ¯æ³„éœ²

```rust
// âŒ å·®ï¼šè®°å½•æ•æ„Ÿä¿¡æ¯
log::info!("User password: {}", password);

// âœ… å¥½ï¼šä¸è®°å½•æ•æ„Ÿä¿¡æ¯
log::info!("User login attempt: {}", username);
```

### ä½¿ç”¨ç±»å‹å®‰å…¨

```rust
// âœ… å¥½ï¼šä½¿ç”¨ newtype æ¨¡å¼
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UserId(String);

impl UserId {
    pub fn new(id: String) -> Self {
        Self(id)
    }
}

// é¿å…æ··æ·†ä¸åŒç±»å‹çš„ ID
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SessionId(String);
```

---

## 6. Git æäº¤è§„èŒƒ

### æäº¤ä¿¡æ¯æ ¼å¼

```
<type>(<scope>): <subject>

<body>

<footer>
```

### ç±»å‹ï¼ˆtypeï¼‰

- `feat`: æ–°åŠŸèƒ½
- `fix`: Bug ä¿®å¤
- `refactor`: ä»£ç é‡æ„
- `docs`: æ–‡æ¡£æ›´æ–°
- `test`: æµ‹è¯•ç›¸å…³
- `chore`: æ„å»º/å·¥å…·ç›¸å…³
- `perf`: æ€§èƒ½ä¼˜åŒ–
- `ci`: CI/CD é…ç½®

### ç¤ºä¾‹

```bash
# ç®€å•æäº¤
git commit -m "feat(btree): å®ç° B-tree èŠ‚ç‚¹ç»“æ„"

# è¯¦ç»†æäº¤
git commit -m "feat(btree): å®ç° B-tree æ’å…¥æ“ä½œ

- å®ç° B-tree èŠ‚ç‚¹åˆ†è£‚é€»è¾‘
- æ·»åŠ é”®å€¼æ’å…¥æ–¹æ³•
- åŒ…å«å•å…ƒæµ‹è¯•

å…³è” Pre æ–‡æ¡£: docs/04_project_management/pr_documents/..."
```

---

## é™„å½•

### å·¥å…·é…ç½®

#### rustfmt.toml

```toml
max_width = 100
hard_tabs = false
tab_spaces = 4
```

#### .clippy.toml

```toml
# è‡ªå®šä¹‰ clippy è§„åˆ™
```

### ç›¸å…³é“¾æ¥

- [Rust API Guidelines](https://rust-lang.github.io/api-guidelines/)
- [Effective Rust](https://doc.rust-lang.org/book/)
- [Rust Style Guide](https://rust-lang.github.io/rustfmt/)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¥æœŸ**: 2026-01-31
**æœ€åæ›´æ–°**: 2026-01-31
**ç»´æŠ¤è€…**: LiteKV å¼€å‘å›¢é˜Ÿ
**çŠ¶æ€**: âœ… å·²æ‰¹å‡†
